\hypertarget{group__cp_space}{}\section{cp\+Space}
\label{group__cp_space}\index{cp\+Space@{cp\+Space}}


Containers for simulating objects in Chipmunk.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structcp_collision_handler}{cp\+Collision\+Handler}
\begin{DoxyCompactList}\small\item\em Struct that holds function callback pointers to configure custom collision handling. \end{DoxyCompactList}\item 
struct \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color}
\begin{DoxyCompactList}\small\item\em Color type to use with the space debug drawing A\+P\+I. \end{DoxyCompactList}\item 
struct \hyperlink{structcp_space_debug_draw_options}{cp\+Space\+Debug\+Draw\+Options}
\begin{DoxyCompactList}\small\item\em Struct used with \hyperlink{group__cp_space_gaa1233930591cb32d25852da2cbe76680}{cp\+Space\+Debug\+Draw()} containing drawing callbacks and other drawing settings. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool}($\ast$ \hyperlink{group__cp_space_ga3134f145bfc7ca4ef69b350978c26a5a}{cp\+Collision\+Begin\+Func}) (\hyperlink{structcp_arbiter}{cp\+Arbiter} $\ast$arb, \hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} user\+Data)
\begin{DoxyCompactList}\small\item\em Collision begin event function callback type. \end{DoxyCompactList}\item 
typedef \hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool}($\ast$ \hyperlink{group__cp_space_ga89b24d53d81a5a028198c3c2d3c39a9d}{cp\+Collision\+Pre\+Solve\+Func}) (\hyperlink{structcp_arbiter}{cp\+Arbiter} $\ast$arb, \hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} user\+Data)
\begin{DoxyCompactList}\small\item\em Collision pre-\/solve event function callback type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaccb60bbb090c97823f49ee49e4e5d3c3}{}typedef void($\ast$ \hyperlink{group__cp_space_gaccb60bbb090c97823f49ee49e4e5d3c3}{cp\+Collision\+Post\+Solve\+Func}) (\hyperlink{structcp_arbiter}{cp\+Arbiter} $\ast$arb, \hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} user\+Data)\label{group__cp_space_gaccb60bbb090c97823f49ee49e4e5d3c3}

\begin{DoxyCompactList}\small\item\em Collision post-\/solve event function callback type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga01427ab634c483879cfed5bb22610487}{}typedef void($\ast$ \hyperlink{group__cp_space_ga01427ab634c483879cfed5bb22610487}{cp\+Collision\+Separate\+Func}) (\hyperlink{structcp_arbiter}{cp\+Arbiter} $\ast$arb, \hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} user\+Data)\label{group__cp_space_ga01427ab634c483879cfed5bb22610487}

\begin{DoxyCompactList}\small\item\em Collision separate event function callback type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga93e9005e387fec86eeb4a225ac295a23}{}typedef void($\ast$ \hyperlink{group__cp_space_ga93e9005e387fec86eeb4a225ac295a23}{cp\+Post\+Step\+Func}) (\hyperlink{structcp_space}{cp\+Space} $\ast$space, void $\ast$key, void $\ast$data)\label{group__cp_space_ga93e9005e387fec86eeb4a225ac295a23}

\begin{DoxyCompactList}\small\item\em Post Step callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga646a55f0937f07c19b24561ed5341221}{}typedef void($\ast$ \hyperlink{group__cp_space_ga646a55f0937f07c19b24561ed5341221}{cp\+Space\+Point\+Query\+Func}) (\hyperlink{structcp_shape}{cp\+Shape} $\ast$shape, \hyperlink{structcp_vect}{cp\+Vect} point, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} distance, \hyperlink{structcp_vect}{cp\+Vect} gradient, void $\ast$data)\label{group__cp_space_ga646a55f0937f07c19b24561ed5341221}

\begin{DoxyCompactList}\small\item\em Nearest point query callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga9046beaeba5728c5e954f0f1dc2ae130}{}typedef void($\ast$ \hyperlink{group__cp_space_ga9046beaeba5728c5e954f0f1dc2ae130}{cp\+Space\+Segment\+Query\+Func}) (\hyperlink{structcp_shape}{cp\+Shape} $\ast$shape, \hyperlink{structcp_vect}{cp\+Vect} point, \hyperlink{structcp_vect}{cp\+Vect} normal, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} alpha, void $\ast$data)\label{group__cp_space_ga9046beaeba5728c5e954f0f1dc2ae130}

\begin{DoxyCompactList}\small\item\em Segment query callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga02779238e9b8c07797aae6139fad203c}{}typedef void($\ast$ \hyperlink{group__cp_space_ga02779238e9b8c07797aae6139fad203c}{cp\+Space\+B\+B\+Query\+Func}) (\hyperlink{structcp_shape}{cp\+Shape} $\ast$shape, void $\ast$data)\label{group__cp_space_ga02779238e9b8c07797aae6139fad203c}

\begin{DoxyCompactList}\small\item\em Rectangle Query callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gab124952dd71dea36688f6ff6ff8bdcb2}{}typedef void($\ast$ \hyperlink{group__cp_space_gab124952dd71dea36688f6ff6ff8bdcb2}{cp\+Space\+Shape\+Query\+Func}) (\hyperlink{structcp_shape}{cp\+Shape} $\ast$shape, \hyperlink{structcp_contact_point_set}{cp\+Contact\+Point\+Set} $\ast$points, void $\ast$data)\label{group__cp_space_gab124952dd71dea36688f6ff6ff8bdcb2}

\begin{DoxyCompactList}\small\item\em Shape query callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga2870b1128c5bfe79cb261d269abdea64}{}typedef void($\ast$ \hyperlink{group__cp_space_ga2870b1128c5bfe79cb261d269abdea64}{cp\+Space\+Body\+Iterator\+Func}) (\hyperlink{structcp_body}{cp\+Body} $\ast$body, void $\ast$data)\label{group__cp_space_ga2870b1128c5bfe79cb261d269abdea64}

\begin{DoxyCompactList}\small\item\em Space/body iterator callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gafae017c9a8a7c082032035bf165e4ec9}{}typedef void($\ast$ \hyperlink{group__cp_space_gafae017c9a8a7c082032035bf165e4ec9}{cp\+Space\+Shape\+Iterator\+Func}) (\hyperlink{structcp_shape}{cp\+Shape} $\ast$shape, void $\ast$data)\label{group__cp_space_gafae017c9a8a7c082032035bf165e4ec9}

\begin{DoxyCompactList}\small\item\em Space/shape iterator callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga0bf20ed2411342352dc43b71c60649c1}{}typedef void($\ast$ \hyperlink{group__cp_space_ga0bf20ed2411342352dc43b71c60649c1}{cp\+Space\+Constraint\+Iterator\+Func}) (\hyperlink{structcp_constraint}{cp\+Constraint} $\ast$constraint, void $\ast$data)\label{group__cp_space_ga0bf20ed2411342352dc43b71c60649c1}

\begin{DoxyCompactList}\small\item\em Space/constraint iterator callback function type. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gafc46fcefca8c28112ca8245eef00bae7}{}typedef struct \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} \hyperlink{group__cp_space_gafc46fcefca8c28112ca8245eef00bae7}{cp\+Space\+Debug\+Color}\label{group__cp_space_gafc46fcefca8c28112ca8245eef00bae7}

\begin{DoxyCompactList}\small\item\em Color type to use with the space debug drawing A\+P\+I. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gab96ab3199114538fa70cb5f7c6b2887a}{}typedef void($\ast$ \hyperlink{group__cp_space_gab96ab3199114538fa70cb5f7c6b2887a}{cp\+Space\+Debug\+Draw\+Circle\+Impl}) (\hyperlink{structcp_vect}{cp\+Vect} pos, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} angle, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} radius, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} outline\+Color, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} fill\+Color, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} data)\label{group__cp_space_gab96ab3199114538fa70cb5f7c6b2887a}

\begin{DoxyCompactList}\small\item\em Callback type for a function that draws a filled, stroked circle. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaed387c6356be81f3da4050547fe47c9e}{}typedef void($\ast$ \hyperlink{group__cp_space_gaed387c6356be81f3da4050547fe47c9e}{cp\+Space\+Debug\+Draw\+Segment\+Impl}) (\hyperlink{structcp_vect}{cp\+Vect} a, \hyperlink{structcp_vect}{cp\+Vect} b, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} color, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} data)\label{group__cp_space_gaed387c6356be81f3da4050547fe47c9e}

\begin{DoxyCompactList}\small\item\em Callback type for a function that draws a line segment. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gab8b2b1f7036daa38914a0d3c2cb1d732}{}typedef void($\ast$ \hyperlink{group__cp_space_gab8b2b1f7036daa38914a0d3c2cb1d732}{cp\+Space\+Debug\+Draw\+Fat\+Segment\+Impl}) (\hyperlink{structcp_vect}{cp\+Vect} a, \hyperlink{structcp_vect}{cp\+Vect} b, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} radius, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} outline\+Color, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} fill\+Color, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} data)\label{group__cp_space_gab8b2b1f7036daa38914a0d3c2cb1d732}

\begin{DoxyCompactList}\small\item\em Callback type for a function that draws a thick line segment. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga2138e846816a1e581a3433740a596ab6}{}typedef void($\ast$ \hyperlink{group__cp_space_ga2138e846816a1e581a3433740a596ab6}{cp\+Space\+Debug\+Draw\+Polygon\+Impl}) (int count, const \hyperlink{structcp_vect}{cp\+Vect} $\ast$verts, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} radius, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} outline\+Color, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} fill\+Color, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} data)\label{group__cp_space_ga2138e846816a1e581a3433740a596ab6}

\begin{DoxyCompactList}\small\item\em Callback type for a function that draws a convex polygon. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gadf9a758a2f1c3b53551829573b722e5a}{}typedef void($\ast$ \hyperlink{group__cp_space_gadf9a758a2f1c3b53551829573b722e5a}{cp\+Space\+Debug\+Draw\+Dot\+Impl}) (\hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} size, \hyperlink{structcp_vect}{cp\+Vect} pos, \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color} color, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} data)\label{group__cp_space_gadf9a758a2f1c3b53551829573b722e5a}

\begin{DoxyCompactList}\small\item\em Callback type for a function that draws a dot. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaba1fec950f2b58c7c72ab5ca553bdf43}{}typedef \hyperlink{structcp_space_debug_color}{cp\+Space\+Debug\+Color}($\ast$ \hyperlink{group__cp_space_gaba1fec950f2b58c7c72ab5ca553bdf43}{cp\+Space\+Debug\+Draw\+Color\+For\+Shape\+Impl}) (\hyperlink{structcp_shape}{cp\+Shape} $\ast$shape, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} data)\label{group__cp_space_gaba1fec950f2b58c7c72ab5ca553bdf43}

\begin{DoxyCompactList}\small\item\em Callback type for a function that returns a color for a given shape. This gives you an opportunity to color shapes based on how they are used in your engine. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaa625807338fd5ebd8f61463dead0c32b}{}typedef enum cp\+Space\+Debug\+Draw\+Flags {\bfseries cp\+Space\+Debug\+Draw\+Flags}\label{group__cp_space_gaa625807338fd5ebd8f61463dead0c32b}

\item 
\hypertarget{group__cp_space_gabb44b3d40332bc5965e8dbd515caa71a}{}typedef struct \hyperlink{structcp_space_debug_draw_options}{cp\+Space\+Debug\+Draw\+Options} \hyperlink{group__cp_space_gabb44b3d40332bc5965e8dbd515caa71a}{cp\+Space\+Debug\+Draw\+Options}\label{group__cp_space_gabb44b3d40332bc5965e8dbd515caa71a}

\begin{DoxyCompactList}\small\item\em Struct used with \hyperlink{group__cp_space_gaa1233930591cb32d25852da2cbe76680}{cp\+Space\+Debug\+Draw()} containing drawing callbacks and other drawing settings. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\hypertarget{group__cp_space_ga12b09b00b23e09d770e4b2ab3980c69a}{}enum {\bfseries cp\+Space\+Debug\+Draw\+Flags} \{ {\bfseries C\+P\+\_\+\+S\+P\+A\+C\+E\+\_\+\+D\+E\+B\+U\+G\+\_\+\+D\+R\+A\+W\+\_\+\+S\+H\+A\+P\+E\+S} = 1$<$$<$0, 
{\bfseries C\+P\+\_\+\+S\+P\+A\+C\+E\+\_\+\+D\+E\+B\+U\+G\+\_\+\+D\+R\+A\+W\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+S} = 1$<$$<$1, 
{\bfseries C\+P\+\_\+\+S\+P\+A\+C\+E\+\_\+\+D\+E\+B\+U\+G\+\_\+\+D\+R\+A\+W\+\_\+\+C\+O\+L\+L\+I\+S\+I\+O\+N\+\_\+\+P\+O\+I\+N\+T\+S} = 1$<$$<$2
 \}\label{group__cp_space_ga12b09b00b23e09d770e4b2ab3980c69a}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{group__cp_space_gaeed23237c8a7b052ec816b339c7e60dd}{}\hyperlink{structcp_space}{cp\+Space} $\ast$ \hyperlink{group__cp_space_gaeed23237c8a7b052ec816b339c7e60dd}{cp\+Space\+Alloc} (void)\label{group__cp_space_gaeed23237c8a7b052ec816b339c7e60dd}

\begin{DoxyCompactList}\small\item\em Allocate a \hyperlink{structcp_space}{cp\+Space}. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga3e668d762b5b6438b51f7af0fb32ff09}{}\hyperlink{structcp_space}{cp\+Space} $\ast$ \hyperlink{group__cp_space_ga3e668d762b5b6438b51f7af0fb32ff09}{cp\+Space\+Init} (\hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_ga3e668d762b5b6438b51f7af0fb32ff09}

\begin{DoxyCompactList}\small\item\em Initialize a \hyperlink{structcp_space}{cp\+Space}. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gac6293d85ec533d496e3005d194c1e62b}{}\hyperlink{structcp_space}{cp\+Space} $\ast$ \hyperlink{group__cp_space_gac6293d85ec533d496e3005d194c1e62b}{cp\+Space\+New} (void)\label{group__cp_space_gac6293d85ec533d496e3005d194c1e62b}

\begin{DoxyCompactList}\small\item\em Allocate and initialize a \hyperlink{structcp_space}{cp\+Space}. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga964c2ec74cf2527fa17142b6009796c5}{}void \hyperlink{group__cp_space_ga964c2ec74cf2527fa17142b6009796c5}{cp\+Space\+Destroy} (\hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_ga964c2ec74cf2527fa17142b6009796c5}

\begin{DoxyCompactList}\small\item\em Destroy a \hyperlink{structcp_space}{cp\+Space}. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga1fe399459fcb74d30eb29a73af26cd0c}{}void \hyperlink{group__cp_space_ga1fe399459fcb74d30eb29a73af26cd0c}{cp\+Space\+Free} (\hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_ga1fe399459fcb74d30eb29a73af26cd0c}

\begin{DoxyCompactList}\small\item\em Destroy and free a \hyperlink{structcp_space}{cp\+Space}. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga60b3be9f6af76aed024a48389d72ab91}{}int \hyperlink{group__cp_space_ga60b3be9f6af76aed024a48389d72ab91}{cp\+Space\+Get\+Iterations} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_ga60b3be9f6af76aed024a48389d72ab91}

\begin{DoxyCompactList}\small\item\em Get number of iterations to use in the impulse solver to solve contacts and other constraints. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaa77e00fe5c3de55f24f70839cea71e26}{}void \hyperlink{group__cp_space_gaa77e00fe5c3de55f24f70839cea71e26}{cp\+Space\+Set\+Iterations} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, int iterations)\label{group__cp_space_gaa77e00fe5c3de55f24f70839cea71e26}

\begin{DoxyCompactList}\small\item\em Set number of iterations to use in the impulse solver to solve contacts and other constraints. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gadf6f7da6298ad15540f35c50cc23017d}{}\hyperlink{structcp_vect}{cp\+Vect} \hyperlink{group__cp_space_gadf6f7da6298ad15540f35c50cc23017d}{cp\+Space\+Get\+Gravity} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_gadf6f7da6298ad15540f35c50cc23017d}

\begin{DoxyCompactList}\small\item\em Get gravity to pass to rigid bodies when integrating velocity. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga37f6b61dc283b65af44efece7d3a8cdc}{}void \hyperlink{group__cp_space_ga37f6b61dc283b65af44efece7d3a8cdc}{cp\+Space\+Set\+Gravity} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_vect}{cp\+Vect} gravity)\label{group__cp_space_ga37f6b61dc283b65af44efece7d3a8cdc}

\begin{DoxyCompactList}\small\item\em Set gravity to pass to rigid bodies when integrating velocity. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} \hyperlink{group__cp_space_gaa22a14eff6829be47341fd0c4fac768e}{cp\+Space\+Get\+Damping} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Get the damping rate expressed as the fraction of velocity bodies retain each second. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_ga03fe1ee78d58a53479dec2ae27b628a4}{cp\+Space\+Set\+Damping} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} damping)
\begin{DoxyCompactList}\small\item\em Set the damping rate expressed as the fraction of velocity bodies retain each second. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} \hyperlink{group__cp_space_gace9f8722a0de8941bef92e4e0a05b3f9}{cp\+Space\+Get\+Idle\+Speed\+Threshold} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Get speed threshold for a body to be considered idle. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_ga0a774d7bddac3cde239b44121b6039d3}{cp\+Space\+Set\+Idle\+Speed\+Threshold} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} idle\+Speed\+Threshold)
\begin{DoxyCompactList}\small\item\em Set speed threshold for a body to be considered idle. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} \hyperlink{group__cp_space_ga607680bfdfa411b79d9154d1a573a8de}{cp\+Space\+Get\+Sleep\+Time\+Threshold} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Get the time a group of bodies must remain idle in order to fall asleep. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_ga96acf0e2cb7f180dc4a514db6e055bb5}{cp\+Space\+Set\+Sleep\+Time\+Threshold} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} sleep\+Time\+Threshold)
\begin{DoxyCompactList}\small\item\em Set the time a group of bodies must remain idle in order to fall asleep. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} \hyperlink{group__cp_space_ga235cd69e2f133d8dfb6213018eea5b01}{cp\+Space\+Get\+Collision\+Slop} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Get amount of encouraged penetration between colliding shapes. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_gaaabdae358883644b1f619276cba26845}{cp\+Space\+Set\+Collision\+Slop} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} collision\+Slop)
\begin{DoxyCompactList}\small\item\em Set amount of encouraged penetration between colliding shapes. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} \hyperlink{group__cp_space_ga32e35ab3bf128b560b3a1103fd2c644a}{cp\+Space\+Get\+Collision\+Bias} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Get how fast overlapping shapes are pushed apart. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_ga9bbaeb01dd9ef4fbe13cf99838e7c02a}{cp\+Space\+Set\+Collision\+Bias} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} collision\+Bias)
\begin{DoxyCompactList}\small\item\em Set how fast overlapping shapes are pushed apart. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gaa24652c104082d0725066ea5ac7dc83f}{cp\+Timestamp} \hyperlink{group__cp_space_gafabc09ef5a4a03c623092d6b4b50e524}{cp\+Space\+Get\+Collision\+Persistence} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Get number of frames that contact information should persist. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_gae892594e3051b0ccb4f932d15d9c986f}{cp\+Space\+Set\+Collision\+Persistence} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gaa24652c104082d0725066ea5ac7dc83f}{cp\+Timestamp} collision\+Persistence)
\begin{DoxyCompactList}\small\item\em Set number of frames that contact information should persist. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} \hyperlink{group__cp_space_ga3b33b522787f17742557672591fb5658}{cp\+Space\+Get\+User\+Data} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Get user definable data pointer. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_ga7d887eb6a99605433c6ab65ede689835}{cp\+Space\+Set\+User\+Data} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_ga2ac2c3c31e21893941f9e4f8ee279447}{cp\+Data\+Pointer} user\+Data)
\begin{DoxyCompactList}\small\item\em Set user definable data pointer. \end{DoxyCompactList}\item 
\hyperlink{structcp_body}{cp\+Body} $\ast$ \hyperlink{group__cp_space_ga170502383e9e56e1e34ad87ed35babea}{cp\+Space\+Get\+Static\+Body} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em The Space provided static body for a given \hyperlink{structcp_space}{cp\+Space}. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} \hyperlink{group__cp_space_gaec07cd16e997fb2765a4cd0209ce942f}{cp\+Space\+Get\+Current\+Time\+Step} (const \hyperlink{structcp_space}{cp\+Space} $\ast$space)
\begin{DoxyCompactList}\small\item\em Returns the current (or most recent) time step used with the given space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gae425962a45eea97567c0ddd8e8417711}{}\hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool} \hyperlink{group__cp_space_gae425962a45eea97567c0ddd8e8417711}{cp\+Space\+Is\+Locked} (\hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_gae425962a45eea97567c0ddd8e8417711}

\begin{DoxyCompactList}\small\item\em returns true from inside a callback when objects cannot be added/removed. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gab3c3b915d1a4f2c0ab51da0e127145f8}{}\hyperlink{structcp_collision_handler}{cp\+Collision\+Handler} $\ast$ \hyperlink{group__cp_space_gab3c3b915d1a4f2c0ab51da0e127145f8}{cp\+Space\+Add\+Default\+Collision\+Handler} (\hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_gab3c3b915d1a4f2c0ab51da0e127145f8}

\begin{DoxyCompactList}\small\item\em Create or return the existing collision handler that is called for all collisions that are not handled by a more specific collision handler. \end{DoxyCompactList}\item 
\hyperlink{structcp_collision_handler}{cp\+Collision\+Handler} $\ast$ \hyperlink{group__cp_space_ga1a530112830b93f746a90284d18b39e7}{cp\+Space\+Add\+Collision\+Handler} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gae83e2f50965eb441e36ffff1e32e6d02}{cp\+Collision\+Type} a, \hyperlink{group__basic_types_gae83e2f50965eb441e36ffff1e32e6d02}{cp\+Collision\+Type} b)
\begin{DoxyCompactList}\small\item\em Create or return the existing collision handler for the specified pair of collision types. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga5ebf7560b11470507395d53b3ed8ec69}{}\hyperlink{structcp_collision_handler}{cp\+Collision\+Handler} $\ast$ \hyperlink{group__cp_space_ga5ebf7560b11470507395d53b3ed8ec69}{cp\+Space\+Add\+Wildcard\+Handler} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gae83e2f50965eb441e36ffff1e32e6d02}{cp\+Collision\+Type} type)\label{group__cp_space_ga5ebf7560b11470507395d53b3ed8ec69}

\begin{DoxyCompactList}\small\item\em Create or return the existing wildcard collision handler for the specified type. \end{DoxyCompactList}\item 
\hyperlink{structcp_shape}{cp\+Shape} $\ast$ \hyperlink{group__cp_space_ga5fd6bdb0b93c93a93eeab0611e070080}{cp\+Space\+Add\+Shape} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_shape}{cp\+Shape} $\ast$shape)
\begin{DoxyCompactList}\small\item\em Add a collision shape to the simulation. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga0aa27863e6410512b73347e25e97b215}{}\hyperlink{structcp_body}{cp\+Body} $\ast$ \hyperlink{group__cp_space_ga0aa27863e6410512b73347e25e97b215}{cp\+Space\+Add\+Body} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_body}{cp\+Body} $\ast$body)\label{group__cp_space_ga0aa27863e6410512b73347e25e97b215}

\begin{DoxyCompactList}\small\item\em Add a rigid body to the simulation. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gad3fc61e25869131d30dca7b1a33ba102}{}\hyperlink{structcp_constraint}{cp\+Constraint} $\ast$ \hyperlink{group__cp_space_gad3fc61e25869131d30dca7b1a33ba102}{cp\+Space\+Add\+Constraint} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_constraint}{cp\+Constraint} $\ast$constraint)\label{group__cp_space_gad3fc61e25869131d30dca7b1a33ba102}

\begin{DoxyCompactList}\small\item\em Add a constraint to the simulation. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaba39a56c766cf5094876685d7ed63734}{}void \hyperlink{group__cp_space_gaba39a56c766cf5094876685d7ed63734}{cp\+Space\+Remove\+Shape} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_shape}{cp\+Shape} $\ast$shape)\label{group__cp_space_gaba39a56c766cf5094876685d7ed63734}

\begin{DoxyCompactList}\small\item\em Remove a collision shape from the simulation. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gad2c0aab926b1796bb38deee21d8a9ef1}{}void \hyperlink{group__cp_space_gad2c0aab926b1796bb38deee21d8a9ef1}{cp\+Space\+Remove\+Body} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_body}{cp\+Body} $\ast$body)\label{group__cp_space_gad2c0aab926b1796bb38deee21d8a9ef1}

\begin{DoxyCompactList}\small\item\em Remove a rigid body from the simulation. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gae6a15d5809c8ca1cd786518b0198061b}{}void \hyperlink{group__cp_space_gae6a15d5809c8ca1cd786518b0198061b}{cp\+Space\+Remove\+Constraint} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_constraint}{cp\+Constraint} $\ast$constraint)\label{group__cp_space_gae6a15d5809c8ca1cd786518b0198061b}

\begin{DoxyCompactList}\small\item\em Remove a constraint from the simulation. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga24236a160025c41df498804da57ebc08}{}\hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool} \hyperlink{group__cp_space_ga24236a160025c41df498804da57ebc08}{cp\+Space\+Contains\+Shape} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_shape}{cp\+Shape} $\ast$shape)\label{group__cp_space_ga24236a160025c41df498804da57ebc08}

\begin{DoxyCompactList}\small\item\em Test if a collision shape has been added to the space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga8aededc0029d164ebd419e6012a91034}{}\hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool} \hyperlink{group__cp_space_ga8aededc0029d164ebd419e6012a91034}{cp\+Space\+Contains\+Body} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_body}{cp\+Body} $\ast$body)\label{group__cp_space_ga8aededc0029d164ebd419e6012a91034}

\begin{DoxyCompactList}\small\item\em Test if a rigid body has been added to the space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga2e4cef3632535e485f1e0645e60c3ad2}{}\hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool} \hyperlink{group__cp_space_ga2e4cef3632535e485f1e0645e60c3ad2}{cp\+Space\+Contains\+Constraint} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_constraint}{cp\+Constraint} $\ast$constraint)\label{group__cp_space_ga2e4cef3632535e485f1e0645e60c3ad2}

\begin{DoxyCompactList}\small\item\em Test if a constraint has been added to the space. \end{DoxyCompactList}\item 
\hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool} \hyperlink{group__cp_space_gae59563596af1bae44c2de59871cde5f8}{cp\+Space\+Add\+Post\+Step\+Callback} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__cp_space_ga93e9005e387fec86eeb4a225ac295a23}{cp\+Post\+Step\+Func} func, void $\ast$key, void $\ast$data)
\begin{DoxyCompactList}\small\item\em Schedule a post-\/step callback to be called when \hyperlink{group__cp_space_gad8a6c8e7e99ae268af224aa199124706}{cp\+Space\+Step()} finishes. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaef2748612847147c8eb496470ccd1611}{}void \hyperlink{group__cp_space_gaef2748612847147c8eb496470ccd1611}{cp\+Space\+Point\+Query} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_vect}{cp\+Vect} point, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} max\+Distance, \hyperlink{structcp_shape_filter}{cp\+Shape\+Filter} filter, \hyperlink{group__cp_space_ga646a55f0937f07c19b24561ed5341221}{cp\+Space\+Point\+Query\+Func} func, void $\ast$data)\label{group__cp_space_gaef2748612847147c8eb496470ccd1611}

\begin{DoxyCompactList}\small\item\em Query the space at a point and call {\ttfamily func} for each shape found. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gad333bad8f98d532657ae7cdc57a18a4a}{}\hyperlink{structcp_shape}{cp\+Shape} $\ast$ \hyperlink{group__cp_space_gad333bad8f98d532657ae7cdc57a18a4a}{cp\+Space\+Point\+Query\+Nearest} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_vect}{cp\+Vect} point, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} max\+Distance, \hyperlink{structcp_shape_filter}{cp\+Shape\+Filter} filter, \hyperlink{structcp_point_query_info}{cp\+Point\+Query\+Info} $\ast$out)\label{group__cp_space_gad333bad8f98d532657ae7cdc57a18a4a}

\begin{DoxyCompactList}\small\item\em Query the space at a point and return the nearest shape found. Returns N\+U\+L\+L if no shapes were found. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga399ad2aeff96199aac2356916daced55}{}void \hyperlink{group__cp_space_ga399ad2aeff96199aac2356916daced55}{cp\+Space\+Segment\+Query} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_vect}{cp\+Vect} start, \hyperlink{structcp_vect}{cp\+Vect} end, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} radius, \hyperlink{structcp_shape_filter}{cp\+Shape\+Filter} filter, \hyperlink{group__cp_space_ga9046beaeba5728c5e954f0f1dc2ae130}{cp\+Space\+Segment\+Query\+Func} func, void $\ast$data)\label{group__cp_space_ga399ad2aeff96199aac2356916daced55}

\begin{DoxyCompactList}\small\item\em Perform a directed line segment query (like a raycast) against the space calling {\ttfamily func} for each shape intersected. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga724f70039c4c1982799a2602939b9339}{}\hyperlink{structcp_shape}{cp\+Shape} $\ast$ \hyperlink{group__cp_space_ga724f70039c4c1982799a2602939b9339}{cp\+Space\+Segment\+Query\+First} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_vect}{cp\+Vect} start, \hyperlink{structcp_vect}{cp\+Vect} end, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} radius, \hyperlink{structcp_shape_filter}{cp\+Shape\+Filter} filter, \hyperlink{structcp_segment_query_info}{cp\+Segment\+Query\+Info} $\ast$out)\label{group__cp_space_ga724f70039c4c1982799a2602939b9339}

\begin{DoxyCompactList}\small\item\em Perform a directed line segment query (like a raycast) against the space and return the first shape hit. Returns N\+U\+L\+L if no shapes were hit. \end{DoxyCompactList}\item 
void \hyperlink{group__cp_space_ga6f74f9dd9fc523b65483d96e2272f0d9}{cp\+Space\+B\+B\+Query} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_b_b}{cp\+B\+B} bb, \hyperlink{structcp_shape_filter}{cp\+Shape\+Filter} filter, \hyperlink{group__cp_space_ga02779238e9b8c07797aae6139fad203c}{cp\+Space\+B\+B\+Query\+Func} func, void $\ast$data)
\begin{DoxyCompactList}\small\item\em Perform a fast rectangle query on the space calling {\ttfamily func} for each shape found. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga8415bcc9318df0a7e50e1e2cc612ccd2}{}\hyperlink{group__basic_types_gabc5e752c48f3449ca26ef413ecbd647e}{cp\+Bool} \hyperlink{group__cp_space_ga8415bcc9318df0a7e50e1e2cc612ccd2}{cp\+Space\+Shape\+Query} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_shape}{cp\+Shape} $\ast$shape, \hyperlink{group__cp_space_gab124952dd71dea36688f6ff6ff8bdcb2}{cp\+Space\+Shape\+Query\+Func} func, void $\ast$data)\label{group__cp_space_ga8415bcc9318df0a7e50e1e2cc612ccd2}

\begin{DoxyCompactList}\small\item\em Query a space for any shapes overlapping the given shape and call {\ttfamily func} for each shape found. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gab526f8e9ea517058d4d90509e971120d}{}void \hyperlink{group__cp_space_gab526f8e9ea517058d4d90509e971120d}{cp\+Space\+Each\+Body} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__cp_space_ga2870b1128c5bfe79cb261d269abdea64}{cp\+Space\+Body\+Iterator\+Func} func, void $\ast$data)\label{group__cp_space_gab526f8e9ea517058d4d90509e971120d}

\begin{DoxyCompactList}\small\item\em Call {\ttfamily func} for each body in the space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gac652c40a648d64651b4b36baab354802}{}void \hyperlink{group__cp_space_gac652c40a648d64651b4b36baab354802}{cp\+Space\+Each\+Shape} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__cp_space_gafae017c9a8a7c082032035bf165e4ec9}{cp\+Space\+Shape\+Iterator\+Func} func, void $\ast$data)\label{group__cp_space_gac652c40a648d64651b4b36baab354802}

\begin{DoxyCompactList}\small\item\em Call {\ttfamily func} for each shape in the space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gac388d8f773c2e080b214734af63a5b64}{}void \hyperlink{group__cp_space_gac388d8f773c2e080b214734af63a5b64}{cp\+Space\+Each\+Constraint} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__cp_space_ga0bf20ed2411342352dc43b71c60649c1}{cp\+Space\+Constraint\+Iterator\+Func} func, void $\ast$data)\label{group__cp_space_gac388d8f773c2e080b214734af63a5b64}

\begin{DoxyCompactList}\small\item\em Call {\ttfamily func} for each constraint in the space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gad703cfe24cb148c49c6dd30aa6b091ff}{}void \hyperlink{group__cp_space_gad703cfe24cb148c49c6dd30aa6b091ff}{cp\+Space\+Reindex\+Static} (\hyperlink{structcp_space}{cp\+Space} $\ast$space)\label{group__cp_space_gad703cfe24cb148c49c6dd30aa6b091ff}

\begin{DoxyCompactList}\small\item\em Update the collision detection info for the static shapes in the space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga4dfab7bb0c43e49b321a5620c459f9d2}{}void \hyperlink{group__cp_space_ga4dfab7bb0c43e49b321a5620c459f9d2}{cp\+Space\+Reindex\+Shape} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_shape}{cp\+Shape} $\ast$shape)\label{group__cp_space_ga4dfab7bb0c43e49b321a5620c459f9d2}

\begin{DoxyCompactList}\small\item\em Update the collision detection data for a specific shape in the space. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_ga93a9cc05205923058aa6c2dcdaeb2d44}{}void \hyperlink{group__cp_space_ga93a9cc05205923058aa6c2dcdaeb2d44}{cp\+Space\+Reindex\+Shapes\+For\+Body} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_body}{cp\+Body} $\ast$body)\label{group__cp_space_ga93a9cc05205923058aa6c2dcdaeb2d44}

\begin{DoxyCompactList}\small\item\em Update the collision detection data for all shapes attached to a body. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gae80141ab89b21e48a10850c3e2c81e91}{}void \hyperlink{group__cp_space_gae80141ab89b21e48a10850c3e2c81e91}{cp\+Space\+Use\+Spatial\+Hash} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} dim, int count)\label{group__cp_space_gae80141ab89b21e48a10850c3e2c81e91}

\begin{DoxyCompactList}\small\item\em Switch the space to use a spatial hash as it\textquotesingle{}s spatial index. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gad8a6c8e7e99ae268af224aa199124706}{}void \hyperlink{group__cp_space_gad8a6c8e7e99ae268af224aa199124706}{cp\+Space\+Step} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{group__basic_types_gac1ed65573e035bf892505768c852d8d3}{cp\+Float} dt)\label{group__cp_space_gad8a6c8e7e99ae268af224aa199124706}

\begin{DoxyCompactList}\small\item\em Step the space forward in time by {\ttfamily dt}. \end{DoxyCompactList}\item 
\hypertarget{group__cp_space_gaa1233930591cb32d25852da2cbe76680}{}void \hyperlink{group__cp_space_gaa1233930591cb32d25852da2cbe76680}{cp\+Space\+Debug\+Draw} (\hyperlink{structcp_space}{cp\+Space} $\ast$space, \hyperlink{structcp_space_debug_draw_options}{cp\+Space\+Debug\+Draw\+Options} $\ast$options)\label{group__cp_space_gaa1233930591cb32d25852da2cbe76680}

\begin{DoxyCompactList}\small\item\em Debug draw the current state of the space using the supplied drawing options. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Containers for simulating objects in Chipmunk. 

Controls how all the rigid bodies, shapes and constraints interact together. 

\subsection{Typedef Documentation}
\hypertarget{group__cp_space_ga3134f145bfc7ca4ef69b350978c26a5a}{}\index{cp\+Space@{cp\+Space}!cp\+Collision\+Begin\+Func@{cp\+Collision\+Begin\+Func}}
\index{cp\+Collision\+Begin\+Func@{cp\+Collision\+Begin\+Func}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Collision\+Begin\+Func}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf cp\+Bool}($\ast$ cp\+Collision\+Begin\+Func) ({\bf cp\+Arbiter} $\ast$arb, {\bf cp\+Space} $\ast$space, {\bf cp\+Data\+Pointer} user\+Data)}\label{group__cp_space_ga3134f145bfc7ca4ef69b350978c26a5a}


Collision begin event function callback type. 

Returning false from a begin callback causes the collision to be ignored until the the separate callback is called when the objects stop colliding. \hypertarget{group__cp_space_ga89b24d53d81a5a028198c3c2d3c39a9d}{}\index{cp\+Space@{cp\+Space}!cp\+Collision\+Pre\+Solve\+Func@{cp\+Collision\+Pre\+Solve\+Func}}
\index{cp\+Collision\+Pre\+Solve\+Func@{cp\+Collision\+Pre\+Solve\+Func}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Collision\+Pre\+Solve\+Func}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf cp\+Bool}($\ast$ cp\+Collision\+Pre\+Solve\+Func) ({\bf cp\+Arbiter} $\ast$arb, {\bf cp\+Space} $\ast$space, {\bf cp\+Data\+Pointer} user\+Data)}\label{group__cp_space_ga89b24d53d81a5a028198c3c2d3c39a9d}


Collision pre-\/solve event function callback type. 

Returning false from a pre-\/step callback causes the collision to be ignored until the next step. 

\subsection{Function Documentation}
\hypertarget{group__cp_space_ga1a530112830b93f746a90284d18b39e7}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Add\+Collision\+Handler@{cp\+Space\+Add\+Collision\+Handler}}
\index{cp\+Space\+Add\+Collision\+Handler@{cp\+Space\+Add\+Collision\+Handler}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Add\+Collision\+Handler}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Collision\+Handler}$\ast$ cp\+Space\+Add\+Collision\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Collision\+Type}}]{a, }
\item[{{\bf cp\+Collision\+Type}}]{b}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga1a530112830b93f746a90284d18b39e7}


Create or return the existing collision handler for the specified pair of collision types. 

If wildcard handlers are used with either of the collision types, it\textquotesingle{}s the responibility of the custom handler to invoke the wildcard handlers. \hypertarget{group__cp_space_gae59563596af1bae44c2de59871cde5f8}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Add\+Post\+Step\+Callback@{cp\+Space\+Add\+Post\+Step\+Callback}}
\index{cp\+Space\+Add\+Post\+Step\+Callback@{cp\+Space\+Add\+Post\+Step\+Callback}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Add\+Post\+Step\+Callback}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Bool} cp\+Space\+Add\+Post\+Step\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Post\+Step\+Func}}]{func, }
\item[{void $\ast$}]{key, }
\item[{void $\ast$}]{data}
\end{DoxyParamCaption}
)}\label{group__cp_space_gae59563596af1bae44c2de59871cde5f8}


Schedule a post-\/step callback to be called when \hyperlink{group__cp_space_gad8a6c8e7e99ae268af224aa199124706}{cp\+Space\+Step()} finishes. 

You can only register one callback per unique value for {\ttfamily key}. Returns true only if {\ttfamily key} has never been scheduled before. It\textquotesingle{}s possible to pass {\ttfamily N\+U\+L\+L} for {\ttfamily func} if you only want to mark {\ttfamily key} as being used. \hypertarget{group__cp_space_ga5fd6bdb0b93c93a93eeab0611e070080}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Add\+Shape@{cp\+Space\+Add\+Shape}}
\index{cp\+Space\+Add\+Shape@{cp\+Space\+Add\+Shape}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Add\+Shape}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Shape}$\ast$ cp\+Space\+Add\+Shape (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Shape} $\ast$}]{shape}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga5fd6bdb0b93c93a93eeab0611e070080}


Add a collision shape to the simulation. 

If the shape is attached to a static body, it will be added as a static shape. \hypertarget{group__cp_space_ga6f74f9dd9fc523b65483d96e2272f0d9}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+B\+B\+Query@{cp\+Space\+B\+B\+Query}}
\index{cp\+Space\+B\+B\+Query@{cp\+Space\+B\+B\+Query}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+B\+B\+Query}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+B\+B\+Query (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+B\+B}}]{bb, }
\item[{{\bf cp\+Shape\+Filter}}]{filter, }
\item[{{\bf cp\+Space\+B\+B\+Query\+Func}}]{func, }
\item[{void $\ast$}]{data}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga6f74f9dd9fc523b65483d96e2272f0d9}


Perform a fast rectangle query on the space calling {\ttfamily func} for each shape found. 

Only the shape\textquotesingle{}s bounding boxes are checked for overlap, not their full shape. \hypertarget{group__cp_space_ga32e35ab3bf128b560b3a1103fd2c644a}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Collision\+Bias@{cp\+Space\+Get\+Collision\+Bias}}
\index{cp\+Space\+Get\+Collision\+Bias@{cp\+Space\+Get\+Collision\+Bias}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Collision\+Bias}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Float} cp\+Space\+Get\+Collision\+Bias (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga32e35ab3bf128b560b3a1103fd2c644a}


Get how fast overlapping shapes are pushed apart. 

Expressed as a fraction of the error remaining after each second. Defaults to pow(1.\+0 -\/ 0.\+1, 60.\+0) meaning that Chipmunk fixes 10\% of overlap each frame at 60\+Hz. \hypertarget{group__cp_space_gafabc09ef5a4a03c623092d6b4b50e524}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Collision\+Persistence@{cp\+Space\+Get\+Collision\+Persistence}}
\index{cp\+Space\+Get\+Collision\+Persistence@{cp\+Space\+Get\+Collision\+Persistence}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Collision\+Persistence}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Timestamp} cp\+Space\+Get\+Collision\+Persistence (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_gafabc09ef5a4a03c623092d6b4b50e524}


Get number of frames that contact information should persist. 

Defaults to 3. There is probably never a reason to change this value. \hypertarget{group__cp_space_ga235cd69e2f133d8dfb6213018eea5b01}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Collision\+Slop@{cp\+Space\+Get\+Collision\+Slop}}
\index{cp\+Space\+Get\+Collision\+Slop@{cp\+Space\+Get\+Collision\+Slop}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Collision\+Slop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Float} cp\+Space\+Get\+Collision\+Slop (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga235cd69e2f133d8dfb6213018eea5b01}


Get amount of encouraged penetration between colliding shapes. 

Used to reduce oscillating contacts and keep the collision cache warm. Defaults to 0.\+1. If you have poor simulation quality, increase this number as much as possible without allowing visible amounts of overlap. \hypertarget{group__cp_space_gaec07cd16e997fb2765a4cd0209ce942f}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Current\+Time\+Step@{cp\+Space\+Get\+Current\+Time\+Step}}
\index{cp\+Space\+Get\+Current\+Time\+Step@{cp\+Space\+Get\+Current\+Time\+Step}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Current\+Time\+Step}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Float} cp\+Space\+Get\+Current\+Time\+Step (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_gaec07cd16e997fb2765a4cd0209ce942f}


Returns the current (or most recent) time step used with the given space. 

Useful from callbacks if your time step is not a compile-\/time global. \hypertarget{group__cp_space_gaa22a14eff6829be47341fd0c4fac768e}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Damping@{cp\+Space\+Get\+Damping}}
\index{cp\+Space\+Get\+Damping@{cp\+Space\+Get\+Damping}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Damping}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Float} cp\+Space\+Get\+Damping (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_gaa22a14eff6829be47341fd0c4fac768e}


Get the damping rate expressed as the fraction of velocity bodies retain each second. 

A value of 0.\+9 would mean that each body\textquotesingle{}s velocity will drop 10\% per second. The default value is 1.\+0, meaning no damping is applied. \begin{DoxyNote}{Note}
This damping value is different than those of \hyperlink{structcp_damped_spring}{cp\+Damped\+Spring} and \hyperlink{structcp_damped_rotary_spring}{cp\+Damped\+Rotary\+Spring}. 
\end{DoxyNote}
\hypertarget{group__cp_space_gace9f8722a0de8941bef92e4e0a05b3f9}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Idle\+Speed\+Threshold@{cp\+Space\+Get\+Idle\+Speed\+Threshold}}
\index{cp\+Space\+Get\+Idle\+Speed\+Threshold@{cp\+Space\+Get\+Idle\+Speed\+Threshold}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Idle\+Speed\+Threshold}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Float} cp\+Space\+Get\+Idle\+Speed\+Threshold (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_gace9f8722a0de8941bef92e4e0a05b3f9}


Get speed threshold for a body to be considered idle. 

The default value of 0 means to let the space guess a good threshold based on gravity. \hypertarget{group__cp_space_ga607680bfdfa411b79d9154d1a573a8de}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Sleep\+Time\+Threshold@{cp\+Space\+Get\+Sleep\+Time\+Threshold}}
\index{cp\+Space\+Get\+Sleep\+Time\+Threshold@{cp\+Space\+Get\+Sleep\+Time\+Threshold}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Sleep\+Time\+Threshold}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Float} cp\+Space\+Get\+Sleep\+Time\+Threshold (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga607680bfdfa411b79d9154d1a573a8de}


Get the time a group of bodies must remain idle in order to fall asleep. 

Enabling sleeping also implicitly enables the the contact graph. The default value of I\+N\+F\+I\+N\+I\+T\+Y disables the sleeping algorithm. \hypertarget{group__cp_space_ga170502383e9e56e1e34ad87ed35babea}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+Static\+Body@{cp\+Space\+Get\+Static\+Body}}
\index{cp\+Space\+Get\+Static\+Body@{cp\+Space\+Get\+Static\+Body}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+Static\+Body}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Body}$\ast$ cp\+Space\+Get\+Static\+Body (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga170502383e9e56e1e34ad87ed35babea}


The Space provided static body for a given \hyperlink{structcp_space}{cp\+Space}. 

This is merely provided for convenience and you are not required to use it. \hypertarget{group__cp_space_ga3b33b522787f17742557672591fb5658}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Get\+User\+Data@{cp\+Space\+Get\+User\+Data}}
\index{cp\+Space\+Get\+User\+Data@{cp\+Space\+Get\+User\+Data}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Get\+User\+Data}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cp\+Data\+Pointer} cp\+Space\+Get\+User\+Data (
\begin{DoxyParamCaption}
\item[{const {\bf cp\+Space} $\ast$}]{space}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga3b33b522787f17742557672591fb5658}


Get user definable data pointer. 

Generally this points to your game\textquotesingle{}s controller or game state class so you can access it when given a \hyperlink{structcp_space}{cp\+Space} reference in a callback. \hypertarget{group__cp_space_ga9bbaeb01dd9ef4fbe13cf99838e7c02a}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Set\+Collision\+Bias@{cp\+Space\+Set\+Collision\+Bias}}
\index{cp\+Space\+Set\+Collision\+Bias@{cp\+Space\+Set\+Collision\+Bias}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Set\+Collision\+Bias}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+Set\+Collision\+Bias (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Float}}]{collision\+Bias}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga9bbaeb01dd9ef4fbe13cf99838e7c02a}


Set how fast overlapping shapes are pushed apart. 

Expressed as a fraction of the error remaining after each second. Defaults to pow(1.\+0 -\/ 0.\+1, 60.\+0) meaning that Chipmunk fixes 10\% of overlap each frame at 60\+Hz. \hypertarget{group__cp_space_gae892594e3051b0ccb4f932d15d9c986f}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Set\+Collision\+Persistence@{cp\+Space\+Set\+Collision\+Persistence}}
\index{cp\+Space\+Set\+Collision\+Persistence@{cp\+Space\+Set\+Collision\+Persistence}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Set\+Collision\+Persistence}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+Set\+Collision\+Persistence (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Timestamp}}]{collision\+Persistence}
\end{DoxyParamCaption}
)}\label{group__cp_space_gae892594e3051b0ccb4f932d15d9c986f}


Set number of frames that contact information should persist. 

Defaults to 3. There is probably never a reason to change this value. \hypertarget{group__cp_space_gaaabdae358883644b1f619276cba26845}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Set\+Collision\+Slop@{cp\+Space\+Set\+Collision\+Slop}}
\index{cp\+Space\+Set\+Collision\+Slop@{cp\+Space\+Set\+Collision\+Slop}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Set\+Collision\+Slop}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+Set\+Collision\+Slop (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Float}}]{collision\+Slop}
\end{DoxyParamCaption}
)}\label{group__cp_space_gaaabdae358883644b1f619276cba26845}


Set amount of encouraged penetration between colliding shapes. 

Used to reduce oscillating contacts and keep the collision cache warm. Defaults to 0.\+1. If you have poor simulation quality, increase this number as much as possible without allowing visible amounts of overlap. \hypertarget{group__cp_space_ga03fe1ee78d58a53479dec2ae27b628a4}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Set\+Damping@{cp\+Space\+Set\+Damping}}
\index{cp\+Space\+Set\+Damping@{cp\+Space\+Set\+Damping}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Set\+Damping}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+Set\+Damping (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Float}}]{damping}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga03fe1ee78d58a53479dec2ae27b628a4}


Set the damping rate expressed as the fraction of velocity bodies retain each second. 

A value of 0.\+9 would mean that each body\textquotesingle{}s velocity will drop 10\% per second. The default value is 1.\+0, meaning no damping is applied. \begin{DoxyNote}{Note}
This damping value is different than those of \hyperlink{structcp_damped_spring}{cp\+Damped\+Spring} and \hyperlink{structcp_damped_rotary_spring}{cp\+Damped\+Rotary\+Spring}. 
\end{DoxyNote}
\hypertarget{group__cp_space_ga0a774d7bddac3cde239b44121b6039d3}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Set\+Idle\+Speed\+Threshold@{cp\+Space\+Set\+Idle\+Speed\+Threshold}}
\index{cp\+Space\+Set\+Idle\+Speed\+Threshold@{cp\+Space\+Set\+Idle\+Speed\+Threshold}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Set\+Idle\+Speed\+Threshold}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+Set\+Idle\+Speed\+Threshold (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Float}}]{idle\+Speed\+Threshold}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga0a774d7bddac3cde239b44121b6039d3}


Set speed threshold for a body to be considered idle. 

The default value of 0 means to let the space guess a good threshold based on gravity. \hypertarget{group__cp_space_ga96acf0e2cb7f180dc4a514db6e055bb5}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Set\+Sleep\+Time\+Threshold@{cp\+Space\+Set\+Sleep\+Time\+Threshold}}
\index{cp\+Space\+Set\+Sleep\+Time\+Threshold@{cp\+Space\+Set\+Sleep\+Time\+Threshold}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Set\+Sleep\+Time\+Threshold}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+Set\+Sleep\+Time\+Threshold (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Float}}]{sleep\+Time\+Threshold}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga96acf0e2cb7f180dc4a514db6e055bb5}


Set the time a group of bodies must remain idle in order to fall asleep. 

Enabling sleeping also implicitly enables the the contact graph. The default value of I\+N\+F\+I\+N\+I\+T\+Y disables the sleeping algorithm. \hypertarget{group__cp_space_ga7d887eb6a99605433c6ab65ede689835}{}\index{cp\+Space@{cp\+Space}!cp\+Space\+Set\+User\+Data@{cp\+Space\+Set\+User\+Data}}
\index{cp\+Space\+Set\+User\+Data@{cp\+Space\+Set\+User\+Data}!cp\+Space@{cp\+Space}}
\subsubsection[{cp\+Space\+Set\+User\+Data}]{\setlength{\rightskip}{0pt plus 5cm}void cp\+Space\+Set\+User\+Data (
\begin{DoxyParamCaption}
\item[{{\bf cp\+Space} $\ast$}]{space, }
\item[{{\bf cp\+Data\+Pointer}}]{user\+Data}
\end{DoxyParamCaption}
)}\label{group__cp_space_ga7d887eb6a99605433c6ab65ede689835}


Set user definable data pointer. 

Generally this points to your game\textquotesingle{}s controller or game state class so you can access it when given a \hyperlink{structcp_space}{cp\+Space} reference in a callback. 